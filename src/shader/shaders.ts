// Warning: this file is automaticaly generated by util/glslLoader.js and executed by nodejs
export namespace ShaderSource {
        export const calculators__blinn_phong_glsl = `vec3 calculateLight(
    vec3 position,
    vec3 normal,
    vec3 lightDir,
    vec3 eyePos,
    vec3 specular,
    vec3 diffuse,
    float shiness,
    float idensity
    ) {
    float lambortian = max(dot(lightDir, normal), 0.0);
    vec3 reflectDir = normalize(reflect(lightDir, normal));
    vec3 viewDir = normalize(eyePos - position);

    // replace R * V with N * H
    vec3 H = (lightDir + viewDir) / length(lightDir + viewDir);
    float specularAngle = max(dot(H, normal), 0.0);

    vec3 specularColor = specular * pow(specularAngle, shiness);
    vec3 diffuseColor = diffuse * lambortian;
    vec3 color = (diffuseColor + specularColor) * idensity;
    return color;
}
`
        export const calculators__blur__gaussian_glsl = `vec4 gaussian_blur(sampler2D origin, vec2 uv, float blurStep, vec2 blurDir) {
    vec4 average = vec4(0.0, 0.0, 0.0, 0.0);
    average += texture2D(origin, uv - 4.0 * blurStep * blurDir) * 0.0162162162;
    average += texture2D(origin, uv - 3.0 * blurStep * blurDir) * 0.0540540541;
    average += texture2D(origin, uv - 2.0 * blurStep * blurDir) * 0.1216216216;
    average += texture2D(origin, uv - 1.0 * blurStep * blurDir) * 0.1945945946;
    average += texture2D(origin, uv) * 0.2270270270;
    average += texture2D(origin, uv + 1.0 * blurStep * blurDir) * 0.1945945946;
    average += texture2D(origin, uv + 2.0 * blurStep * blurDir) * 0.1216216216;
    average += texture2D(origin, uv + 3.0 * blurStep * blurDir) * 0.0540540541;
    average += texture2D(origin, uv + 4.0 * blurStep * blurDir) * 0.0162162162;
    return average;
}
`
        export const calculators__blur__gaussian_log_glsl = `
`
        export const calculators__linearlize_depth_glsl = `float linearlizeDepth(float far, float near, float depth) {
    float NDRDepth = depth * 2.0 - 1.0;;
    return 2.0 * near / (near + far - NDRDepth * (far - near));
}
`
        export const calculators__packFloat1x32_glsl = `vec4 packFloat1x32(float val)
{
    vec4 pack = vec4(1.0, 255.0, 65025.0, 16581375.0) * val;
    pack = fract(pack);
    pack -= vec4(pack.yzw / 255.0, 0.0);
    return pack;
}
`
        export const calculators__phong_glsl = `vec3 calculateLight(
    vec3 position,
    vec3 normal,
    vec3 lightDir,
    vec3 eyePos,
    vec3 specularLight,
    vec3 diffuseLight,
    float shiness,
    float idensity
    ) {
    float lambortian = max(dot(lightDir, normal), 0.0);
    vec3 reflectDir = normalize(reflect(lightDir, normal));
    vec3 viewDir = normalize(eyePos - position);
    float specularAngle = max(dot(reflectDir, viewDir), 0.0);
    vec3 specularColor = specularLight * pow(specularAngle, shiness);
    vec3 diffuseColor = diffuse * lambortian;
    return (diffuseColor + specularColor) * idensity;
}
`
        export const calculators__shadow_factor_glsl = `float getSpotDirectionShadow(vec2 clipPos, sampler2D shadowMap, float linearDepth, float lambertian, float texelSize)
{
    vec2 uv = clipPos * 0.5 + 0.5;
    
    vec2 f = fract(uv / texelSize - 0.5);
    vec2 centroidUV = (floor(uv / texelSize - 0.5)) * texelSize;

    float lb = texture2D(shadowMap, centroidUV + texelSize * vec2(0.0, 0.0)).r;
    float lt = texture2D(shadowMap, centroidUV + texelSize * vec2(0.0, 1.0)).r;
    float rb = texture2D(shadowMap, centroidUV + texelSize * vec2(1.0, 0.0)).r;
    float rt = texture2D(shadowMap, centroidUV + texelSize * vec2(1.0, 1.0)).r;
    float a = lb + log(mix(1.0, exp(lt - lb), f.y));
    float b = rb + log(mix(1.0, exp(rt - rb), f.y));
    float z = a + log(mix(1.0, exp(b - a), f.x));

    float bias = clamp(0.1 * tan(acos(lambertian)), 0.0, 1.0);

    float s = exp((z + bias - linearDepth));

    return min(s, 1.0);
}
`
        export const calculators__types_glsl = `vec3 calculateDirLight(
    DirectLight light,
    vec3 materialDiff,
    vec3 materialSpec,
    float materialSpecExp,
    vec3 position,
    vec3 normal,
    vec3 eyePos
    ) {
    return calculateLight(
        position,
        normal,
        -light.direction,
        eyePos,
        light.color * materialSpec,
        light.color * materialDiff,
        materialSpecExp,
        light.idensity
    );
}

vec3 calculatePointLight(
    PointLight light,
    vec3 materialDiff,
    vec3 materialSpec,
    float materialSpecExp,
    vec3 position,
    vec3 normal,
    vec3 eyePos
    ) {
    float lightDis = length(light.position - position);
    float idensity = light.idensity / (light.constantAtten + light.linearAtten * lightDis + light.squareAtten * lightDis * lightDis);
    idensity *= step(lightDis, light.radius);
    return calculateLight(
        position,
        normal,
        normalize(light.position - position),
        eyePos,
        light.color * materialSpec,
        light.color * materialDiff,
        materialSpecExp,
        idensity
    );
}

vec3 calculateSpotLight(
    SpotLight light,
    vec3 materialDiff,
    vec3 materialSpec,
    float materialSpecExp,
    vec3 position,
    vec3 normal,
    vec3 eyePos
    ) {
    vec3 lightDir = normalize(light.position - position);
    float spotFactor = dot(-lightDir, light.spotDir);
    if (spotFactor < light.coneAngleCos) {
        return vec3(0.0);
    }
    float lightDis = length(light.position - position);
    float idensity = light.idensity / (light.constantAtten + light.linearAtten * lightDis + light.squareAtten * lightDis * lightDis);
    idensity *= (spotFactor - light.coneAngleCos) / (1.0 - light.coneAngleCos);
    // idensity *= step(light.radius, lightDis);
    return calculateLight(
        position,
        normal,
        lightDir,
        eyePos,
        light.color * materialSpec,
        light.color * materialDiff,
        materialSpecExp,
        idensity
    );
}

// float directAndSpotShadow(sampler2D shadowMap, vec4 shadowCoord) {
//
// }
`
        export const calculators__unpackFloat1x32_glsl = `float unpackFloat1x32( vec4 rgba ) {
  return dot( rgba, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0) );
}
`
        export const debug__checkBox_glsl = `float checkerBoard(in vec2 uv, in float subSize) {
    vec2 bigBox = mod(uv, vec2(subSize * 2.0));
    return (
        step(subSize, bigBox.x) * step(subSize, bigBox.y)
        + step(subSize, subSize * 2.0 -bigBox.x) * step(subSize, subSize * 2.0 -bigBox.y)
    );
}
`
        export const definitions__light_glsl = `struct DirectLight
{
    vec3 color;
    float idensity;
    vec3 direction;
#ifdef USE_SHADOW
    float shadowMapSize;
    mat4 projectionMatrix;
    mat4 viewMatrix;
#endif
};

struct PointLight {
    vec3 color;
    float idensity;
    float radius;
    vec3 position;
    float squareAtten;
    float linearAtten;
    float constantAtten;
#ifdef USE_SHADOW
    float shadowMapSize;
    mat4 projectionMatrix;
    mat4 viewMatrix;
    float pcssArea;
#endif
};

struct SpotLight {
    vec3 color;
    float idensity;
    float radius;
    vec3 position;
    float squareAtten;
    float linearAtten;
    float constantAtten;
    float coneAngleCos;
    vec3 spotDir;
#ifdef USE_SHADOW
    float shadowMapSize;
    mat4 projectionMatrix;
    mat4 viewMatrix;
    float pcssArea;
#endif
};
`
        export const interploters__deferred__geometry_frag = `uniform vec3 ambient;
uniform vec3 uMaterialDiff;
uniform vec3 uMaterialSpec;
uniform float uMaterialSpecExp;

uniform vec3 eyePos;
varying vec3 vNormal;

#ifdef _MAIN_TEXTURE
uniform sampler2D uMainTexture;
varying vec2 vMainUV;
#endif

#ifdef _NORMAL_TEXTURE
uniform sampler2D uNormalTexture;
varying vec2 vNormalUV;
#endif

vec2 encodeNormal(vec3 n) {
    return normalize(n.xy) * (sqrt(n.z*0.5+0.5));
}

void main () {
    vec3 normal = normalize(vNormal);
    float specular = (uMaterialSpec.x + uMaterialSpec.y + uMaterialSpec.z) / 3.0;
#ifdef _NORMAL_TEXTURE
    gl_FragData[0] = vec4(encodeNormal(normal), gl_FragCoord.z, uMaterialSpecExp);
#else
    gl_FragData[0] = vec4(encodeNormal(normal), gl_FragCoord.z, uMaterialSpecExp);
#endif
#ifdef _MAIN_TEXTURE
    gl_FragData[1] = vec4(uMaterialDiff * texture2D(uMainTexture, vMainUV).xyz, specular);
#else
    gl_FragData[1] = vec4(uMaterialDiff, specular);
#endif
}
`
        export const interploters__deferred__geometry_vert = `attribute vec3 position;
uniform mat4 modelViewProjectionMatrix;

#ifdef _MAIN_TEXTURE
attribute vec2 aMainUV;
varying vec2 vMainUV;
#endif

uniform mat4 normalViewMatrix;
attribute vec3 aNormal;
varying vec3 vNormal;

void main (){
    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);
    vNormal = (normalViewMatrix * vec4(aNormal, 1.0)).xyz;

#ifdef _MAIN_TEXTURE
    vMainUV = aMainUV;
#endif
}
`
        export const interploters__deferred__tiledLight_frag = `#define MAX_TILE_LIGHT_NUM 32

precision highp float;

uniform float uHorizontalTileNum;
uniform float uVerticalTileNum;
uniform float uLightListLengthSqrt;

uniform mat4 inverseProjection;

uniform sampler2D uLightIndex;
uniform sampler2D uLightOffsetCount;
uniform sampler2D uLightPositionRadius;
uniform sampler2D uLightColorIdensity;

uniform sampler2D uNormalDepthSE;
uniform sampler2D uDiffSpec;

uniform float cameraNear;
uniform float cameraFar;


varying vec3 vPosition;

vec3 decodeNormal(vec2 n)
{
   vec3 normal;
   normal.z = dot(n, n) * 2.0 - 1.0;
   normal.xy = normalize(n) * sqrt(1.0 - normal.z * normal.z);
   return normal;
}

vec3 decodePosition(float depth) {
    vec4 clipSpace = vec4(vPosition.xy, depth * 2.0 - 1.0, 1.0);
    vec4 homogenous = inverseProjection * clipSpace;
    return homogenous.xyz / homogenous.w;
}

void main() {
    vec2 uv = vPosition.xy * 0.5 + vec2(0.5);
    vec2 gridIndex = uv ;// floor(uv * vec2(uHorizontalTileNum, uVerticalTileNum)) / vec2(uHorizontalTileNum, uVerticalTileNum);
    vec4 lightIndexInfo = texture2D(uLightOffsetCount, gridIndex);
    float lightStartIndex = lightIndexInfo.r;
    float lightNum = lightIndexInfo.w;
    vec4 tex1 = texture2D(uNormalDepthSE, uv);
    vec4 tex2 = texture2D(uDiffSpec, uv);

    vec3 materialDiff = tex2.xyz;
    vec3 materialSpec = vec3(tex2.w);
    float materialSpecExp = tex1.w;

    vec3 normal = decodeNormal(tex1.xy);
    vec3 viewPosition = decodePosition(tex1.z);
    vec3 totalColor = vec3(0.0);
    int realCount = 0;
    for(int i = 0; i < MAX_TILE_LIGHT_NUM; i++) {
        if (float(i) > lightNum - 0.5) {
            break;
        }
        // float listX = (float(lightStartIndex + i) - listX_int * uLightListLengthSqrt) / uLightListLengthSqrt;
        // float listY = ((lightStartIndex + i) / uLightListLengthSqrt) / uLightListLengthSqrt;
        // float listX = (mod(lightStartIndex + i, uLightListLengthSqrt)) / uLightListLengthSqrt;
        // listX = 1.0;
        // listY = 0.0;
        float fixlightId = texture2D(uLightIndex, vec2((lightStartIndex + float(i)) / uLightListLengthSqrt, 0.5)).x;
        vec4 lightPosR = texture2D(uLightPositionRadius, vec2(fixlightId, 0.5));
        vec3 lightPos = lightPosR.xyz;
        float lightR = lightPosR.w;
        vec4 lightColorIden = texture2D(uLightColorIdensity, vec2(fixlightId, 0.5));
        vec3 lightColor = lightColorIden.xyz;
        float lightIdensity = lightColorIden.w;

        float dist = distance(lightPos, viewPosition);
        if (dist < lightR) {
            realCount++;
            vec3 fixLightColor = lightColor * min(1.0,  1.0 / (dist * dist ) / (lightR * lightR));
            totalColor += calculateLight(
                viewPosition,
                normal,
                normalize(lightPos - viewPosition),
                vec3(0.0),
                materialSpec * lightColor,
                materialDiff * lightColor,
                materialSpecExp,
                lightIdensity
            );
            // totalColor += vec3(listX, listY, 0.0);
        }
            // vec3 lightDir = normalize(lightPos - viewPosition);
            // vec3 reflectDir = normalize(reflect(lightDir, normal));
            // vec3 viewDir = normalize( - viewPosition);
            // vec3 H = normalize(lightDir + viewDir);
            // float specularAngle = max(dot(H, normal), 0.0);
            // // vec3 specularColor = materialSpec * pow(specularAngle, materialSpecExp);
        // totalColor = vec3(float(lightStartIndex) / uLightListLengthSqrt / uLightListLengthSqrt);
        //}
        //}
    }
    // vec3 depth = vec3(linearlizeDepth(cameraFar, cameraNear, tex1.z));
    // vec3 depth = vec3(tex1.z);
    vec3 test = vec3(float(realCount) / 32.0);
    gl_FragColor = vec4(totalColor, 1.0);
}
`
        export const interploters__deferred__tiledLight_vert = `attribute vec3 position;
varying vec3 vPosition;

void main()
{
    gl_Position = vec4(position, 1.0);
    vPosition = position;
}
`
        export const interploters__forward__esm__blur_frag = `uniform sampler2D uOrigin;
uniform vec2 uBlurDir;
uniform float uBlurStep;

uniform float lightArea;

#define MAX_BLOCK_SAMPLE 8.0
#define MAX_PCF_SAMPLE 8.0

uniform float blockSamples;
uniform float PCFSamples;

varying vec4 vProjPos;
varying vec3 vNormal;

void main () {
    vec2 uv = vProjPos.xy * 0.5 + 0.5;
    float base = texture2D(uOrigin, uv).r;
    float block = 0.0;
    gl_FragColor.r = base;

    for (float i = 0.0; i < MAX_BLOCK_SAMPLE; ++i) {
        if(i >= blockSamples) {
            break;
        }
        float d = texture2D(uOrigin, uv + (i - blockSamples / 2.0) * uBlurStep * uBlurDir).r;
        block += step(base, d) * d / blockSamples;
    }
    
    float kenelSize = lightArea * (base - block) / base;

    float sum = 0.0;

    for (float i = 0.0; i < MAX_PCF_SAMPLE; ++i) {
        if(i >= PCFSamples) {
            break;
        }
        float expd = exp(texture2D(uOrigin, uv + (i - PCFSamples / 2.0) * kenelSize * uBlurStep * uBlurDir).r - base);
        sum += expd / PCFSamples;
    }

    float average = log(sum) + base;

    gl_FragColor.r += average;
}
`
        export const interploters__forward__esm__blur_vert = `uniform mat4 normalMatrix;
attribute vec3 position;
attribute vec3 normal;
varying vec4 vProjPos;
varying vec3 vNormal;

void main () {
    gl_Position = vProjPos = vec4(position, 1.0);
    vNormal = normalize((normalMatrix * vec4(normal, 1.0)).xyz);
}
`
        export const interploters__forward__esm__depth_frag = `varying vec3 viewPos;

void main () {
    gl_FragColor.r = -viewPos.z;
}
`
        export const interploters__forward__esm__depth_vert = `attribute vec3 position;
uniform mat4 modelViewProjectionMatrix;
uniform mat4 modelViewMatrix;
varying vec3 viewPos;

void main () {
    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);
    viewPos = (modelViewMatrix * vec4(position, 1.0)).xyz;
}
`
        export const interploters__forward__gouraud_frag = `attribute vec3 position;
uniform mat4 modelViewProjectionMatrix;

void main() {
    textureColor = colorOrMainTexture(vMainUV);
#ifdef OPEN_LIGHT
    totalLighting = ambient;
    vec3 normal = normalize(vNormal);
    gl_FragColor = vec4(totalLighting, 1.0);
#else
#ifdef USE_COLOR
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
#endif
#endif
#ifdef _MAIN_TEXTURE
    gl_FragColor = gl_FragColor * textureColor;
#endif
#ifdef USE_COLOR
    gl_FragColor = gl_FragColor * color;
#endif
}
`
        export const interploters__forward__gouraud_vert = `attribute vec3 position;
uniform mat4 modelViewProjectionMatrix;

attribute vec2 aMainUV;
varying vec2 vMainUV;

void main (){
    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);
#ifdef OPEN_LIGHT
    vec3 normal = (normalMatrix * vec4(aNormal, 0.0)).xyz;
    totalLighting = ambient;
    normal = normalize(normal);
    for (int index = 0; index < LIGHT_NUM; index++) {
        totalLighting += calculate_light(gl_Position, normal, lights[index].position, eyePos, lights[index].specular, lights[index].diffuse, 4, lights[index].idensity);
    }
    vLightColor = totalLighting;
#endif
#ifdef _MAIN_TEXTURE
    vTextureCoord = aTextureCoord;
#endif
}
`
        export const interploters__forward__phong_frag = `uniform vec3 ambient;
uniform vec3 uMaterialSpec;
uniform float uMaterialSpecExp;
uniform vec3 uMaterialDiff;

uniform vec3 cameraPos;

varying vec2 vMainUV;
varying vec4 clipPos;

varying vec3 vNormal;
varying vec3 vPosition;

#ifdef _MAIN_TEXTURE
uniform sampler2D uMainTexture;
#endif

#ifdef _ENVIRONMENT_MAP
uniform float reflectivity;
uniform samplerCube uCubeTexture;
#endif

#if (directLightsNum > 0)
uniform DirectLight directLights[directLightsNum];
uniform sampler2D directLightShadowMap[directLightsNum];
#endif

#if (pointLightsNum > 0)
uniform PointLight pointLights[pointLightsNum];
#endif

#if (spotLightsNum > 0)
uniform SpotLight spotLights[spotLightsNum];
uniform sampler2D spotLightShadowMap[spotLightsNum];
#endif

#ifdef USE_SHADOW

    #if (directLightsNum > 0)
    varying vec4 directShadowCoord[directLightsNum];
    varying float directLightDepth[directLightsNum];
    #endif

    #if (pointLightsNum > 0)
    varying vec4 pointShadowCoord[pointLightsNum];
    varying float pointLightDepth[pointLightsNum];
    #endif

    #if (spotLightsNum > 0)
    varying vec4 spotShadowCoord[spotLightsNum];
    varying float spotLightDepth[spotLightsNum];
    #endif

#endif

void main () {

#ifdef _MAIN_TEXTURE
    gl_FragColor = texture2D(uMainTexture, vMainUV);
#else
    #ifdef _DEBUG
    gl_FragColor = vec4(vec3(checkerBoard(vMainUV, 0.1)), 1.0);
    #else
    gl_FragColor = vec4(1.0);
    #endif
#endif
    vec3 color = vec3(0.0);
    vec3 normal = normalize(vNormal);
    vec3 totalLighting = ambient;
    #ifdef _ENVIRONMENT_MAP
    vec3 viewDir = normalize(-vPosition);
    vec3 skyUV = reflect(viewDir, vNormal);
    totalLighting = mix(totalLighting, textureCube(uCubeTexture, skyUV).xyz, reflectivity);
    #endif
#if (directLightsNum > 0)
    for (int index = 0; index < directLightsNum; index++) {
        vec3 lighting = calculateDirLight(
            directLights[index],
            uMaterialDiff,
            uMaterialSpec,
            uMaterialSpecExp,
            vPosition,
            normal,
            cameraPos
        );
    #ifdef USE_SHADOW
        float lambertian = dot(-directLights[index].direction, normal);
        float shadowFactor = getSpotDirectionShadow(
            directShadowCoord[index].xy / directShadowCoord[index].w, 
            directLightShadowMap[index], 
            directLightDepth[index], 
            lambertian, 
            1.0 / directLights[index].shadowMapSize
        );
        lighting *= shadowFactor;
    #endif
        totalLighting += lighting;
    }
#endif
#if (pointLightsNum > 0)
    for (int index = 0; index < pointLightsNum; index++) {
        vec3 lighting = calculatePointLight(
            pointLights[index],
            uMaterialDiff,
            uMaterialSpec,
            uMaterialSpecExp,
            vPosition,
            normal,
            cameraPos
        );
        totalLighting += lighting;
    }
#endif
#if (spotLightsNum > 0)
    for (int index = 0; index < spotLightsNum; index++) {
        vec3 lighting = calculateSpotLight(
            spotLights[index],
            uMaterialDiff,
            uMaterialSpec,
            uMaterialSpecExp,
            vPosition,
            normal,
            cameraPos
        );
    #ifdef USE_SHADOW
        float lambertian = dot(-spotLights[index].spotDir, normal);
        float shadowFactor = getSpotDirectionShadow(
            spotShadowCoord[index].xy / spotShadowCoord[index].w, 
            spotLightShadowMap[index],
            spotLightDepth[index], 
            lambertian, 
            1.0 / spotLights[index].shadowMapSize
        );
        lighting *= shadowFactor;
    #endif
        totalLighting += lighting;

    }
#endif
    color += totalLighting;
    gl_FragColor *= vec4(color, 1.0);
}
`
        export const interploters__forward__phong_vert = `attribute vec3 position;
uniform mat4 modelViewProjectionMatrix;
uniform mat4 modelMatrix;

attribute vec2 aMainUV;
varying vec2 vMainUV;

uniform mat4 normalMatrix;
attribute vec3 aNormal;
varying vec3 vNormal;
varying vec3 vPosition;
varying vec4 clipPos;


#if (directLightsNum > 0)
uniform DirectLight directLights[directLightsNum];
    #ifdef USE_SHADOW
    varying vec4 directShadowCoord[directLightsNum];
    varying float directLightDepth[directLightsNum];
    #endif
#endif

#if (pointLightsNum > 0)
uniform PointLight pointLights[pointLightsNum];
    #ifdef USE_SHADOW
    varying vec4 pointShadowCoord[pointLightsNum];
    varying float pointLightDepth[pointLightsNum];
    #endif
#endif

#if (spotLightsNum > 0)
uniform SpotLight spotLights[spotLightsNum];
    #ifdef USE_SHADOW
    varying vec4 spotShadowCoord[spotLightsNum];
    varying float spotLightDepth[spotLightsNum];
    #endif
#endif


void main (){
    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);
    clipPos = gl_Position;
    vec4 worldPos = (modelMatrix * vec4(position, 1.0));
    vPosition = worldPos.xyz;
    vNormal = (normalMatrix * vec4(aNormal, 1.0)).xyz;
    vMainUV = aMainUV;

    #ifdef USE_SHADOW
        #if (directLightsNum > 0)
        for (int i = 0; i < directLightsNum; ++i) {
            directShadowCoord[i] = directLights[i].projectionMatrix * directLights[i].viewMatrix * worldPos;
            directLightDepth[i] = -(directLights[i].viewMatrix * worldPos).z;
        }
        #endif

        #if (pointLightsNum > 0)
        for (int i = 0; i < pointLightsNum; ++i) {
            pointShadowCoord[i] = pointLights[i].projectionMatrix * pointLights[i].viewMatrix * worldPos;
            pointLightDepth[i] = -(pointLights[i].viewMatrix * worldPos).z;
        }
        #endif

        #if (spotLightsNum > 0)
        for (int i = 0; i < spotLightsNum; ++i) {
            spotShadowCoord[i] = spotLights[i].projectionMatrix * spotLights[i].viewMatrix * worldPos;
            spotLightDepth[i] = -(spotLights[i].viewMatrix * worldPos).z;
        }
        #endif
    #endif
}
`
        export const interploters__forward__skybox_frag = `varying vec3 cubeUV;
uniform samplerCube uCubeTexture;
void main()
{
    gl_FragColor = textureCube(uCubeTexture, cubeUV);
}
`
        export const interploters__forward__skybox_vert = `attribute vec3 position;
uniform mat4 viewProjectionMatrix;
varying vec3 cubeUV;

void main (){
    vec4 mvp = viewProjectionMatrix * vec4(position, 1.0);
    cubeUV = position;
    gl_Position = mvp.xyww;
}
`
}
    export type ShaderLib = 
        typeof ShaderSource.calculators__blinn_phong_glsl |
        typeof ShaderSource.calculators__blur__gaussian_glsl |
        typeof ShaderSource.calculators__blur__gaussian_log_glsl |
        typeof ShaderSource.calculators__linearlize_depth_glsl |
        typeof ShaderSource.calculators__packFloat1x32_glsl |
        typeof ShaderSource.calculators__phong_glsl |
        typeof ShaderSource.calculators__shadow_factor_glsl |
        typeof ShaderSource.calculators__types_glsl |
        typeof ShaderSource.calculators__unpackFloat1x32_glsl |
        typeof ShaderSource.debug__checkBox_glsl |
        typeof ShaderSource.definitions__light_glsl;
    export type ShadingVert = 
        typeof ShaderSource.interploters__deferred__geometry_vert |
        typeof ShaderSource.interploters__deferred__tiledLight_vert |
        typeof ShaderSource.interploters__forward__esm__blur_vert |
        typeof ShaderSource.interploters__forward__esm__depth_vert |
        typeof ShaderSource.interploters__forward__gouraud_vert |
        typeof ShaderSource.interploters__forward__phong_vert |
        typeof ShaderSource.interploters__forward__skybox_vert;
    export type ShadingFrag = 
        typeof ShaderSource.interploters__deferred__geometry_frag |
        typeof ShaderSource.interploters__deferred__tiledLight_frag |
        typeof ShaderSource.interploters__forward__esm__blur_frag |
        typeof ShaderSource.interploters__forward__esm__depth_frag |
        typeof ShaderSource.interploters__forward__gouraud_frag |
        typeof ShaderSource.interploters__forward__phong_frag |
        typeof ShaderSource.interploters__forward__skybox_frag;