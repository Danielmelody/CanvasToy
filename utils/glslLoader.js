let fs = require('fs');

let walkSync = function(dir, filelist) {
  files = fs.readdirSync(dir);
  filelist = filelist || [];
  files.forEach(function(file) {
    if (fs.statSync(dir + '/' + file).isDirectory()) {
      filelist = walkSync(dir + '/' + file + '/', filelist);
    } else {
      filelist.push(dir + '/' + file);
    }
  });
  return filelist;
};

function exportShaderSource(results, sources, stringEnum) {
  results.push(`    export type ${stringEnum} = `);
  for (let i in sources) {
    let line = '        typeof ShaderSource.' + sources[i];
    if (i == sources.length - 1) {
      line += ';';
    } else {
      line += ' |'
    }
    results.push(line);
  }
}

function read() {
  let srcs = walkSync('src/shader/sources');
  let libs = [];
  let shadingFrag = [];
  let shadingVert = [];
  let results = [
    '// Warning: this file is automaticaly generated by util/glslLoader.js and executed by nodejs',
    'namespace CanvasToy {',
    '    export namespace ShaderSource {',
  ];
  for (let i in srcs) {
    let varName = srcs[i].replace(/[\/|\.]/g, '_');
    varName = varName.replace('src_shader_sources_', '');
    if (varName.match(/glsl/)) {
      libs.push(varName);
    } else if (varName.match(/frag/)) {
      shadingFrag.push(varName);
    } else {
      shadingVert.push(varName);
    }
    let content = fs.readFileSync(srcs[i], 'utf-8');
    content = content.split('\n');
    content = content.join('\\n');
    let out = '        export const ' + varName + ' = "' + content + '"';
    results.push(out);
  }
  results.push('}');

  // export shader libs as string enums;
  exportShaderSource(results, libs, "ShaderLib")

  // export shading methods as string enums;
  exportShaderSource(results, shadingVert, "ShadingVert")

  // export shading methods as string enums;
  exportShaderSource(results, shadingFrag, "ShadingFrag")

  results.push('}');

  let resultStr = results.join('\n');
  fs.writeFileSync('src/shader/shaders.ts', resultStr);
}
read();
